(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{306:function(t,s,a){"use strict";a.r(s);var v=a(14),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"二、并发一致性问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、并发一致性问题"}},[t._v("#")]),t._v(" 二、并发一致性问题")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#二、并发一致性问题"}},[t._v("二、并发一致性问题")]),s("ul",[s("li",[s("a",{attrs:{href:"#丢失修改"}},[t._v("丢失修改")])]),s("li",[s("a",{attrs:{href:"#读脏数据"}},[t._v("读脏数据")])]),s("li",[s("a",{attrs:{href:"#不可重复读"}},[t._v("不可重复读")])]),s("li",[s("a",{attrs:{href:"#幻影读"}},[t._v("幻影读")])])])])])]),t._v("\n在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。"),s("p"),t._v(" "),s("h3",{attrs:{id:"丢失修改"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#丢失修改"}},[t._v("#")]),t._v(" 丢失修改")]),t._v(" "),s("p",[t._v("丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T"),s("sub",[t._v("1")]),t._v(" 和 T"),s("sub",[t._v("2")]),t._v(" 两个事务都对一个数据进行修改，T"),s("sub",[t._v("1")]),t._v(" 先修改并提交生效，T"),s("sub",[t._v("2")]),t._v(" 随后修改，T"),s("sub",[t._v("2")]),t._v(" 的修改覆盖了 T"),s("sub",[t._v("1")]),t._v(" 的修改。")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"}})]),s("br"),t._v(" "),s("h3",{attrs:{id:"读脏数据"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#读脏数据"}},[t._v("#")]),t._v(" 读脏数据")]),t._v(" "),s("p",[t._v("读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T"),s("sub",[t._v("1")]),t._v(" 修改一个数据但未提交，T"),s("sub",[t._v("2")]),t._v(" 随后读取这个数据。如果 T"),s("sub",[t._v("1")]),t._v(" 撤销了这次修改，那么 T"),s("sub",[t._v("2")]),t._v(" 读取的数据是脏数据。")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"}})]),s("br"),t._v(" "),s("h3",{attrs:{id:"不可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[t._v("#")]),t._v(" 不可重复读")]),t._v(" "),s("p",[t._v("不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T"),s("sub",[t._v("2")]),t._v(" 读取一个数据，T"),s("sub",[t._v("1")]),t._v(" 对该数据做了修改。如果 T"),s("sub",[t._v("2")]),t._v(" 再次读取这个数据，此时读取的结果和第一次读取的结果不同。")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"}})]),s("br"),t._v(" "),s("h3",{attrs:{id:"幻影读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幻影读"}},[t._v("#")]),t._v(" 幻影读")]),t._v(" "),s("p",[t._v("幻读本质上也属于不可重复读的情况，T"),s("sub",[t._v("1")]),t._v(" 读取某个范围的数据，T"),s("sub",[t._v("2")]),t._v(" 在这个范围内插入新的数据，T"),s("sub",[t._v("1")]),t._v(" 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:"https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"}})]),s("br"),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。")])])}),[],!1,null,null,null);s.default=_.exports}}]);